using System;
using System.Security.Cryptography;
using System.Text;
using API.Data;
using API.DTOs;
using API.Entities;
using API.Extensions;
using API.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace API.Controllers;

// It is the framework's responsibility to create the AppDbContext instance once an object is created from this class, and it is also the framework's responsibility to dispose of it once this account controller is out of scope
// public class AccountController(AppDbContext context, ITokenService tokenService) : BaseAPIController
public class AccountController(UserManager<AppUser> userManager, ITokenService tokenService) : BaseAPIController
{
  [HttpPost("register")] // .../api/account/register
  // Note that all the parameters are strings this will make the API controller to look for a query string that matches these parameters and not the body of the request! If all the parameters match the controller will also bind the values to these parameters. If we wat to bind to the request's body we cannot use plain strings but rather create an object - a DTO (Data Transfer Object)
  // public async Task<ActionResult<AppUser>> Register(string email, string displayName, string password)
  public async Task<ActionResult<UserDTO>> Register(RegisterDTO registerDTO)
  {
    // No need for this check because it is enforced by the ASPNet Identity
    // if (await EmailExists(registerDTO.Email))
    // {
    //   return BadRequest("Email taken");
    // }
    // Normally, when the account controller is out of scope the HMACSHA512 will be left without resource and wait for the garbage collector to dispose of it. If we don't want to wait for the garbage collection and dispose the class immediatelly after the controller is out of scope we can use the 'using' keyword for that. We can do this type of actions only on classes that implement the iDisposable interface. Here the HMACSHA512 class has a parent which also derives from a parent and so on. The 4th parent implements the iDisposable interface and therefore the HMACSHA512 supports the Dispose method
    // using var hmac = new HMACSHA512(); // No need for that. Generated by the ASPNet Identity

    var user = new AppUser
    {
      DisplayName = registerDTO.DisplayName,
      Email = registerDTO.Email,
      // PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(registerDTO.Password)), // The Encoding.UTF8.GetBytes converts the password into bytes array
      // PasswordSalt = hmac.Key,
      // Need to define the username for the Identity package, even if not required in the AppUser entity
      UserName = registerDTO.Email,
      Member = new Member
      {
        DisplayName = registerDTO.DisplayName,
        Gender = registerDTO.Gender,
        City = registerDTO.City,
        Country = registerDTO.Country,
        DateOfBirth = registerDTO.DateOfBirth
      }
    };
    /* OLD DbContext Code
    // Adding the user to the DB
    context.Users.Add(user); // context.Users refer to the Users table in the DB. This line tells the entity framework to track what is going on with this entity
    // Saving the inserted data
    await context.SaveChangesAsync(); // This line will save any of those track changes to the DB
    */
    // New ASPNet Identity code
    var result = await userManager.CreateAsync(user, registerDTO.Password);
    if (!result.Succeeded)
    {
      // The IdentityResult has an array of errors meaning it can provide multiple errors. Here we are looping on these errors and adding an error message to the model state which is an object that contains the state of the selected model (the IdentityResult in this case)
      foreach (var error in result.Errors)
      {
        ModelState.AddModelError("Identity", error.Description);
      }
      return ValidationProblem(); //Creates an ActionResult that produces a StatusCodes.Status400BadRequest response with validation errors from ControllerBase.ModelState
    }
    var roleResult = await userManager.AddToRoleAsync(user, "Member");
    // Checking for errors
    if (!roleResult.Succeeded)
    {
      foreach (var error in roleResult.Errors)
      {
        ModelState.AddModelError("Role", error.Description);
      }
      Console.WriteLine("Problem with assigning a role on registration");
    }

    await SetRefreshTokenCookie(user);

    return await user.ToDTO(tokenService);
  }

  // No need for that function because of the ASPNet
  // private async Task<bool> EmailExists(string email)
  // {
  //   return await context.Users.AnyAsync(x => x.Email!.ToLower() == email.ToLower());
  // }

  [HttpPost("login")]
  public async Task<ActionResult<UserDTO>> Login(LoginDTO loginDTO) // Note that when sending an object the API controller will search at the body of the request. If we want to send a body but look at the query string we need to specify it using the [FromQuery] notation before the object. Will look like this: Login([FromQuery]LoginDTO loginDTO). The other way around is also possible. If we want to pass strings but get the data from the body we could use [FromBody]
  {
    // There are a lot more options depending on the developer's needs - FirstOrDefaultAsync, LastOrDefaultAsync - which we can also use. Need to read the descriptions of each option to select the best one
    var user = await userManager.FindByEmailAsync(loginDTO.Email);
    if (user == null)
    {
      return Unauthorized("Invalid email address");

    }
    // Validating the password
    /*
    using var hmac = new HMACSHA512(user.PasswordSalt); // Passing the PasswordSalt will ensure that we will get the same hash that was generated when the user was created. We can see it in the register method where we set the PasswordSalt to the hmac.key, the key that was randomly generated when a new HMACSHA512 was instantiated with no parameters

    var computedHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(loginDTO.Password));
    for (var i = 0; i < computedHash.Length; i++)
    {
      if (computedHash[i] != user.PasswordHash[i])
      {
        return Unauthorized("Invalid password");
      }
    }
    */

    // Checking the password using the Identity:
    var result = await userManager.CheckPasswordAsync(user, loginDTO.Password);
    if (!result) return Unauthorized("Invalid password");

    await SetRefreshTokenCookie(user);

    return await user.ToDTO(tokenService);
  }

  [HttpPost("refresh-token")]
  public async Task<ActionResult<UserDTO>> RefreshToken()
  {
    var refreshToken = Request.Cookies["refreshToken"];
    if (refreshToken == null) return NoContent();
    // Getting the user only if the tokens match but the token is expired. Otherwise we will return UnAuthorized
    var user = await userManager.Users.FirstOrDefaultAsync(x => x.RefreshToken == refreshToken && x.RefreshTokenExpiry > DateTime.UtcNow);

    if (user == null) return Unauthorized();
    await SetRefreshTokenCookie(user);
    return await user.ToDTO(tokenService);
  }

  // This function will be executed at the end of the register / login in order to set the cookie then.
  // When we are using cookies we also have to add them in the Cors policy in the Program.cs class by adding the AllowCredentials() to the UseCors method.
  private async Task SetRefreshTokenCookie(AppUser user)
  {
    var refreshToken = tokenService.GenerateRefreshToken();
    user.RefreshToken = refreshToken;
    user.RefreshTokenExpiry = DateTime.UtcNow.AddDays(7);
    await userManager.UpdateAsync(user);

    var cookieOptions = new CookieOptions
    {
      HttpOnly = true, // That means that the cookie is not accessible from any type of javascript, including our own application. This means that it will not be possible to access the cookie from the client side
      Secure = true, // This means that this cookie will be sent only on HTTPS and not HTTP so we need to make sure that we are working in HTTPS also in development
      SameSite = SameSiteMode.Strict, // This means that the cookie will be sent only from our application
      Expires = DateTime.UtcNow.AddDays(7) // The cookie will be removed from the browser after 7 days
    };
    Response.Cookies.Append("refreshToken", refreshToken, cookieOptions);
  }

  // Removing the token of the user on logout
  [Authorize]
  [HttpPost("logout")]
  public async Task<ActionResult> Logout()
  {
    await userManager.Users
      .Where(x => x.Id == User.GetMemberId())
      .ExecuteUpdateAsync(setters => setters
        .SetProperty(x => x.RefreshToken, _ => null)
        .SetProperty(x => x.RefreshTokenExpiry, _ => null)
      );
    Response.Cookies.Delete("refreshToken");
    return Ok();
  }
}
// dotnet ef database drop - This command will delete the DB. Because we are using sqlite, the db file will be deleted
// dotnet ef database update - In case of no DB, this will create the DB file with the appropriate fields (columns)